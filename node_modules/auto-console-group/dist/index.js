/*!
 *  @module      auto-console-group v1.2.9
 *
 *  @description Automagically group console logs in the browser console.
 *
 *  @author      David J. Bradshaw <info@iframe-resizer.com>
 *  @see         {@link https://github.com/davidjbradshaw/auto-console-group#readme}
 *  @license     MIT
 *
 *  @copyright  (c) 2025, David J. Bradshaw. All rights reserved.
 */

const T = "font-weight: normal;", H = "font-weight: bold;", S = "font-style: italic;", U = T + S, N = "color: #135CD2;", k = "color: #A9C7FB;", j = "color: #1F1F1F;", Q = "color: #E3E3E3;", f = "default", _ = "error", C = "log", q = Object.freeze({
  assert: !0,
  error: !0,
  warn: !0
}), L = {
  expand: !0,
  defaultEvent: void 0,
  event: void 0,
  label: "AutoConsoleGroup",
  showTime: !0
}, P = {
  profile: 0,
  profileEnd: 0,
  timeStamp: 0,
  trace: 0
}, V = (o) => {
  const t = o.event || o.defaultEvent;
  return t ? `${t}` : "";
}, u = Object.assign(console);
function W() {
  const o = /* @__PURE__ */ new Date(), t = (l, d) => o[l]().toString().padStart(d, "0"), r = t("getHours", 2), c = t("getMinutes", 2), s = t("getSeconds", 2), i = t("getMilliseconds", 3);
  return `@ ${r}:${c}:${s}.${i}`;
}
const { fromEntries: b, keys: z } = Object, K = (o) => [
  o,
  u[o]
], X = (o) => (t) => [
  t,
  function(r) {
    o[t] = r;
  }
], E = (o, t) => b(z(o).map(t));
function J(o = {}) {
  const t = {}, r = {}, c = [], s = {
    ...L,
    // @ts-expect-error: backwards compatibility
    expand: !o.collapsed || L.expanded,
    ...o
  };
  let i = "";
  function l() {
    c.length = 0, i = "";
  }
  function d() {
    delete s.event, l();
  }
  const v = () => c.some(([e]) => e in q), O = () => v() ? !0 : !!s.expand, A = () => s.showTime ? i : "";
  function h() {
    if (c.length === 0) {
      d();
      return;
    }
    u[O() ? "group" : "groupCollapsed"](
      `%c${s.label}%c ${V(s)} %c${A()}`,
      T,
      H,
      U
    );
    for (const [e, ...n] of c)
      u.assert(
        e in u,
        `Unknown console method: ${e}`
      ), e in u && u[e](...n);
    u.groupEnd(), d();
  }
  function p() {
    i === "" && (i = W());
  }
  function G(e) {
    p(), s.event = e;
  }
  function D() {
    p(), queueMicrotask(() => queueMicrotask(h));
  }
  function a(e, ...n) {
    c.length === 0 && D(), c.push([e, ...n]);
  }
  const M = (e) => (...n) => {
    let m;
    try {
      m = e(...n);
    } catch (g) {
      if (Error.prototype.isPrototypeOf(g)) a(_, g);
      else throw g;
    }
    return m;
  };
  function I(e, ...n) {
    e || a("assert", e, ...n);
  }
  function R(e = f) {
    r[e] ? r[e] += 1 : r[e] = 1, a(C, `${e}: ${r[e]}`);
  }
  function x(e = f) {
    delete r[e];
  }
  function y(e = f) {
    p(), t[e] = performance.now();
  }
  function w(e = f, ...n) {
    if (!t[e]) {
      a("timeLog", e, ...n);
      return;
    }
    const m = performance.now() - t[e];
    a(C, `${e}: ${m} ms`, ...n);
  }
  function B(e = f) {
    w(e), delete t[e];
  }
  const F = (e) => [
    e,
    (...n) => a(e, ...n)
  ];
  return {
    ...E(s, X(s)),
    ...E(console, F),
    ...E(P, K),
    assert: I,
    count: R,
    countReset: x,
    endAutoGroup: h,
    errorBoundary: M,
    event: G,
    purge: l,
    time: y,
    timeEnd: B,
    timeLog: w,
    touch: p
  };
}
const $ = typeof window > "u" || typeof window.matchMedia != "function" ? !1 : window.matchMedia("(prefers-color-scheme: dark)").matches, Y = $ ? k : N, Z = $ ? Q : j;
export {
  H as BOLD,
  Z as FOREGROUND,
  Y as HIGHLIGHT,
  S as ITALIC,
  T as NORMAL,
  J as default
};
